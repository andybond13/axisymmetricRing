/*******************************************************************************

  Class <cartRing> 

  Author: Martin Hautefeuille
          Duke Computational Mechanics Lab (DCML)
          Duke University - Durham, NC (USA)
  E-mail: mh186@duke.edu

  Copyright (c) 2010 Martin Hautefeuille. All rights reserved. No warranty. No
  liability.

*******************************************************************************/
#include "cartRing.h"
#include <stdlib.h>
#include <time.h>
#include <iostream>
#include <stdio.h>
#include <math.h>
#include <sys/stat.h>
#include "str_ops.hpp"
#include <stdlib.h>
#include <time.h>

#define PI 3.14159265358979323846

/*******************************************************************************

                M E T H O D S    F O R    R E S O L U T I O N 

*******************************************************************************/

/*------------------------------- P U B L I C --------------------------------*/

CartRing::CartRing ( const double length, const double crossSec,
                     const double density, const double YoungMod,
                     const int nodNum, const std::string path  ) {

    // affect input values to attributes
    _L = length;
    _A = crossSec;
    _rho = density;
    _E = YoungMod;
    _Nx = nodNum;
    _R0 = _L/(2*PI);
    _c = sqrt( _E / _rho );
    _path = path;

     time_t rawtime;
     time ( &rawtime );
     struct tm * tinf = localtime ( &rawtime );

     // name for the log file
     std::string minutes = ( tinf->tm_min < 10 )
                         ? "0"+StrOps<int>::convert(tinf->tm_min)
                         : StrOps<int>::convert(tinf->tm_min);
    _logPath = _path + "/cartRing" + StrOps<unsigned>::convert( _Nx ) + "_"
             + StrOps<int>::convert( tinf->tm_mon+1 ) + "-"
             + StrOps<int>::convert( tinf->tm_mday+0 ) + "-"
             + StrOps<int>::convert( tinf->tm_year+1900 ) + "_"
             + StrOps<int>::convert( tinf->tm_hour ) + ":"
             + minutes + ".log";
    FILE * pFile;
    pFile = fopen ( _logPath.c_str(), "w" );
    if ( !pFile ) {
        // create the directory tree
        mkdir( _path.c_str(), 0777 );
        std::string datPath = _path+"/datFiles";
        mkdir( datPath.c_str(), 0777 );
        std::string pngPath = _path+"/pngFiles";
        mkdir( pngPath.c_str(), 0777 );
        std::string gnuPath = _path+"/gnuplot";
        mkdir( gnuPath.c_str(), 0777 );
        std::string vtkPath = _path+"/vtkFiles";
        mkdir( vtkPath.c_str(), 0777 );
        printClean();
        pFile = fopen( _logPath.c_str(), "w" );
    }
    else {
        // clean the directory tree
        std::string shellCmd = _path+"/clean.sh";
        system( shellCmd.c_str() );
    }
    fprintf ( pFile, "## Log file for cartring.h\n" );
    fprintf ( pFile, "##   Number of elements: %u\n", _Nx );
    fprintf ( pFile, "##   Start on: %s\n\n", asctime( tinf ) );
    fclose( pFile );


    // build the mesh
    buildDiscretization ();

    // set _DisplayFlag and _tFlag to false and _deactive to zero
    _DisplayFlag = false;
    _tFlag.resize(2);
    _tFlag[0] = 0;
    _tFlag[1] = 0;
}

CartRing::CartRing() {}

CartRing::~CartRing () {
    // create a plot file if necessary
    if ( _NodesToPlot.size() != 0 || _ElmsToPlot.size() != 0 ) {
        std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
        FILE * pFileP;
        pFileP = fopen( plotFil.c_str(), "w" );
        fprintf( pFileP, "#!/bin/bash\n" );
        fprintf( pFileP, "# shell script generated by <ring.h>" );
        fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
        if ( _NodesToPlot.size() != 0 ) {
            std::string velRFil = "./gnuplot/plotRadialVelo.plt";
            fprintf( pFileP, "gnuplot %s\n", velRFil.c_str() );
            std::string velTFil =  "./gnuplot/plotCircumVelo.plt";
            fprintf( pFileP, "gnuplot %s\n", velTFil.c_str() );
        }
        if ( _ElmsToPlot.size() != 0 ) {
            std::string streFil = "./gnuplot/plotStre.plt";
            fprintf( pFileP, "gnuplot %s\n", streFil.c_str() );
        }
        if ( _EnrgFile.size() != 0 ) {
            std::string enrgFil = "./gnuplot/plotEnrg.plt";
            fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
        }
        if ( _CohLawFile.size() != 0 ) {
            std::string cohLawFil = "./gnuplot/plotCohLaw.plt";
            fprintf( pFileP, "gnuplot %s\n", cohLawFil.c_str() );
        }
        if ( _FragFile.size() != 0 ) {
            std::string fragFil = "./gnuplot/plotFragInfo.plt";
            fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
        }
        if ( _HistoFile.size() != 0 ) {
            std::string histoFil = "./gnuplot/plotHisto.plt";
            fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
        }
        if ( _SThetaFile.size() != 0 ) {
            std::string sThetaFil = "./gnuplot/plotSTheta.plt";
            fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
        }
        fprintf( pFileP, "\ngwenview ./pngFiles/* &\n" );
        fclose( pFileP );
        chmod( plotFil.c_str(), 0775 );
    }
}

void CartRing::setCohLaw ( const std::string& lawTyp,
                           const std::vector<std::vector<double> >& param ) {

    if ( lawTyp.compare( 0 , 5, "LINSD" ) == 0 ) {
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            }
            else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            }
            else {
                std::cout << "param[0].size() and # of cohesive links "
                          << "mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == 1 ) {
                _DelC.assign( _Nx, param[1][0] );
            }
            else if ( param[1].size() == _Nx ) {
                _DelC.assign( param[1].begin(), param[1].end() );
            }
            else {
                std::cout << "param[1].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[1][0]
                          << " is considered for all the elements"
                          << std::endl;
                _DelC.assign( _Nx, param[1][0] );
            }
        }
        else {
             std::cout << "LINSD requires two parameters sigma_c and delta_c"
                       << std::endl; 
        }
    }
    else if ( lawTyp.compare( 0, 5, "LINSG" ) == 0 ) {
        if ( param.size() >= 2 ) {
            // _SigC
            if ( param[0].size() == 1 ) {
                _SigC.assign( _Nx, param[0][0] );
            }
            else if ( param[0].size() == _Nx ) {
                _SigC.assign( param[0].begin(), param[0].end() );
            }
            else {
                std::cout << "param[0].size() and # of cohesive links"
                          << " mismatch!!\n"
                          << "only the first value " << param[0][0]
                          << " is considered for all the elements"
                          << std::endl;
                _SigC.assign( _Nx, param[0][0] );
            }
            // _DelC
            if ( param[1].size() == _Nx ) {
                _DelC.resize( _Nx );
                if ( param[0].size() != _Nx ) {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][i] / param[0][0];
                    }
                }
                else {
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][i] / param[0][i];
                    }
                }
            }
            else {
                if ( param[0].size() != _Nx ) {
                    _DelC.assign( _Nx, 2 * param[1][0] / param[0][0] );
                }
                else {
                    _DelC.resize( _Nx );
                    for ( unsigned i = 0; i < _Nx; i++ ) {
                        _DelC[i] = 2 * param[1][0] / param[0][i];
                    }
                }
                if ( param[1].size() != 1 ) {
                    std::cout << "param[1].size() and # of cohesive links"
                              << " mismatch!!\n"
                              << "only the first value " << param[1][0]
                              << " is considered for all the elements"
                              << std::endl;
                }
            }
        }
        else {
             std::cout << "LINSG requires two parameters sigma_c and delta_c"
                       << std::endl; 
        }
    }
    else {
        std::cout << lawTyp << " has not yet been implemented!!" << std::endl;
    }

    // resize _ActivCoh and _D
    _ActivCoh.assign( _Nx, false );
    _ActivCohEnergy.resize(2);
    _ActivCohEnergy[0] = 0; _ActivCohEnergy[1] = 0;
    _D.resize( _Nx );
    _delta.resize( _Nx );
    _sigCoh.resize( _Nx );
    for ( unsigned i = 0; i < _Nx; i++ ) {
        _D[i].resize(2);
    }
}

void CartRing::applyForc ( const std::string& loadTyp,
                           const std::string& loadDir,
                           const double loadVal ) {

    unsigned type = 0;
    if ( loadTyp.compare( 0, 4, "CONS") == 0 ) {
        type = 1;
    }
    else if ( loadTyp.compare( 0, 4, "LINE") == 0 ) {
        type = 2;
    }
    else {
        std::cout << "Load type " << loadTyp << " not yet implemented!"
                  << std::endl;
    }

    if ( loadDir.compare( 0, 5, "RADIA") == 0 ) {
        _NodForcBC[0] = type;
        _ValForcBC[0] = loadVal;
    }
    else if ( loadDir.compare( 0, 5, "THETA") == 0 ) {
        _NodForcBC[1] = type;
        _ValForcBC[1] = loadVal;
    }
    else {
        std::cout << "Direction " << loadDir << " unknown !" << std::endl; 
    }
}

void CartRing::applyVel (  const std::string& velDir, const double velVal  ) {
    //Constant Velocity / Strain Rate Case
    initVel(velDir, velVal);
    _ConstSRFlag = 1;
    if ( velDir.compare( 0, 5, "RADIA") == 0 ) {
        _ValVelBC[0] = 1;
        _ValVelBC[1] = velVal;
    }
    else if ( velDir.compare( 0, 5, "THETA") == 0 ) {
        _ValVelBC[0] = 2;
        _ValVelBC[1] = velVal;
    }
    else {
        std::cout << "Direction " << velDir << " unknown! " << std::endl; 
    }
}

void CartRing::initVel ( const std::string& velDir, const double velVal ) {
    if ( velDir.compare( 0, 5, "RADIA") == 0 ) {
        for ( unsigned i = 0; i < _Vel.size(); i++ ) {
            _Vel[i][0][0] = velVal * cosTheta(i);
            _Vel[i][0][1] = velVal * sinTheta(i);
        }
	_ValForcBC[0] = velVal;
    }
    else if ( velDir.compare( 0, 5, "THETA") == 0 ) {
        for ( unsigned i = 0; i < _Vel.size(); i++ ) {
            _Vel[i][0][0] = -1.0 * velVal * sinTheta(i);
            _Vel[i][0][1] = velVal * cosTheta(i);
        }
    }
    else {
        std::cout << "Direction " << velDir << " unknown! " << std::endl; 
    }
    _Wext += 0.5 * (_m * 2 * _Nx) * pow( velVal , 2);

}

void CartRing::solve ( const double endTime, const unsigned printFrequency, const double refine ) {

    // Print stuff
    if ( _DisplayFlag ) {
        printVtk( _Nt );
    }

    while ( _T < endTime ) {
        // Compute the time-step
        /*
            _Dt = alpha * _Dt_c with 0.8 < alpha < 0.98
            see [Belytschko, pp. 315]
        */ 
        _Dt = 0.8 * _Dt_c;
	//double refine = .4; //time-step refinement factor - used alone and as refine^2
	timeStepRefine(refine);	

        // Increase current time and time-step, update time-step flag
        _T += _Dt;
        _Nt++;
	_tFlag[0] = _tFlag[1];
	_tFlag[1] = 0;
	
        // Explicit Newmark
        NewmarkPred();
        NewmarkReso();
        NewmarkCorr();

	//Check stability
 	checkStable();		//enables the adaptive time-stepping

	//Count the number of fragments
	fragCount();

        // Energy balance check
        energBalance();

        // Update
        update();

        // Print stuff
        if ( _DisplayFlag ) {
	    if (_numFrag >= 1) {
                if ( _Nt % _DtPrintFrac == 0 ) {
                    printVtk( _Nt );
		}
	    } else {
                if ( _Nt % _DtPrintElas == 0 ) {
                    printVtk( _Nt );
		}
            }
        }
        if ( _Nt % _Nx == 0 ) {
	    printSTheta();
	}

	if ( (( _Nt - 1 ) % printFrequency) == 0 ) {
            printNodalInfo();
            printElmInfo();
	    printCohLaw();
            printFrags();
	    printGlobalInfo();
	}
    }
    std::cout << "---------------------------" << std::endl;
    std::cout << "Execution Finished" << std::endl;
    std::cout << "Number of Fragments:   " << _numFrag << std::endl;
    std::cout << "Number of Iterations:  " << _Nt << std::endl;
    std::cout << "Final Cohesive Energy: " << _Wcoh[0] << std::endl;
    std::cout << "Final Stability Ratio: " << _Wsum / _Wmax << std::endl;
    std::cout << "---------------------------" << std::endl;

    time_t rawtime;
    time ( &rawtime );
    struct tm * tinf = localtime ( &rawtime );

    FILE * pFile;
    pFile = fopen ( _logPath.c_str(), "a" );
    fprintf( pFile, "\n\n## Execution finished\n" );
    fprintf( pFile, "##    time: %s", asctime( tinf ) );
    fprintf( pFile, "##    number of fragments: %u\n", _numFrag );
    fprintf( pFile, "##    number of iterations: %u\n", _Nt );
    fprintf( pFile, "##    final cohesive energy: %e\n", _Wcoh[0] );
    fprintf( pFile, "##    final stability ratio: %e\n", _Wsum/_Wmax );
    fclose( pFile );
}

void CartRing::printHisto() {
    // Prints Histogram and scaled 1-cdf figure
    if (_numFrag > 1) {
        plotHisto();
	_fragInvCDF.resize(2);
	_fragInvCDF[0].resize(1000);
	_fragInvCDF[1].resize(1000);
	_fHisto.assign(25, 0);
	
	//Histogram
        double max = _fMax;	//_Nx * _Dx
	for (unsigned k = 0; k < _fragLength.size(); k++){
	    if (_fragLength[k] < max * 0.04){
		_fHisto[0] += 1;
	    }
	    if ((_fragLength[k] < max * 0.08) && (_fragLength[k] >= max * 0.04)) {
		_fHisto[1] += 1;
	    }
	    if ((_fragLength[k] < max * 0.12) && (_fragLength[k] >= max * 0.08)) {
		_fHisto[2] += 1;
	    }
	    if ((_fragLength[k] < max * 0.16) && (_fragLength[k] >= max * 0.12)) {
		_fHisto[3] += 1;
	    }
	    if ((_fragLength[k] < max * 0.20) && (_fragLength[k] >= max * 0.16)) {
		_fHisto[4] += 1;
	    }
	    if ((_fragLength[k] < max * 0.24) && (_fragLength[k] >= max * 0.20)) {
		_fHisto[5] += 1;
	    }
	    if ((_fragLength[k] < max * 0.28) && (_fragLength[k] >= max * 0.24)) {
		_fHisto[6] += 1;
	    }
	    if ((_fragLength[k] < max * 0.32) && (_fragLength[k] >= max * 0.28)) {
		_fHisto[7] += 1;
	    }
	    if ((_fragLength[k] < max * 0.36) && (_fragLength[k] >= max * 0.32)) {
		_fHisto[8] += 1;
	    }
	    if ((_fragLength[k] < max * 0.40) && (_fragLength[k] >= max * 0.36)) {
		_fHisto[9] += 1;
	    }
	    if ((_fragLength[k] < max * 0.44) && (_fragLength[k] >= max * 0.40)) {
		_fHisto[10] += 1;
	    }
	    if ((_fragLength[k] < max * 0.48) && (_fragLength[k] >= max * 0.44)) {
		_fHisto[11] += 1;
	    }
	    if ((_fragLength[k] < max * 0.52) && (_fragLength[k] >= max * 0.48)) {
		_fHisto[12] += 1;
	    }
	    if ((_fragLength[k] < max * 0.56) && (_fragLength[k] >= max * 0.52)) {
		_fHisto[13] += 1;
	    }
	    if ((_fragLength[k] < max * 0.60) && (_fragLength[k] >= max * 0.56)) {
		_fHisto[14] += 1;
	    }
	    if ((_fragLength[k] < max * 0.64) && (_fragLength[k] >= max * 0.60)) {
		_fHisto[15] += 1;
	    }
	    if ((_fragLength[k] < max * 0.68) && (_fragLength[k] >= max * 0.64)) {
		_fHisto[16] += 1;
	    }
	    if ((_fragLength[k] < max * 0.72) && (_fragLength[k] >= max * 0.68)) {
		_fHisto[17] += 1;
	    }
	    if ((_fragLength[k] < max * 0.76) && (_fragLength[k] >= max * 0.72)) {
		_fHisto[18] += 1;
	    }
	    if ((_fragLength[k] < max * 0.80) && (_fragLength[k] >= max * 0.76)) {
		_fHisto[19] += 1;
	    }
	    if ((_fragLength[k] < max * 0.84) && (_fragLength[k] >= max * 0.80)) {
		_fHisto[20] += 1;
	    }
	    if ((_fragLength[k] < max * 0.88) && (_fragLength[k] >= max * 0.84)) {
		_fHisto[21] += 1;
	    }
	    if ((_fragLength[k] < max * 0.92) && (_fragLength[k] >= max * 0.88)) {
		_fHisto[22] += 1;
	    }
	    if ((_fragLength[k] < max * 0.96) && (_fragLength[k] >= max * 0.92)) {
		_fHisto[23] += 1;
	    }
	    if ((_fragLength[k] <= max) && (_fragLength[k] >= max * 0.96)) {
		_fHisto[24] += 1;
	    }
	}

	if ( _HistoFile.size() > 0 ) {
	    FILE * pFile;
	    pFile = fopen( _HistoFile.c_str(), "a" );
	    double j = 0;
	    for (unsigned i = 0; i < 1000; i++) {
		unsigned count = 0;
		j = _fragLength [_numFrag - 1] * (i / 1000.0);
		for (unsigned k = 0; k < _numFrag; k++) {
		    if (_fragLength[k] > j) {
			count += 1;
		    }
		}
                _fragInvCDF[0][i] = j;
		_fragInvCDF[1][i] = (double)count;
		fprintf( pFile, "%12.3e %u", j, count);

	        if (i < 25) {
		    fprintf( pFile, " %f %u", (double)(i*4+2), _fHisto[i] );
	        } else {
		    fprintf( pFile, " 0 0");
		}
		fprintf( pFile, "\n" );
	    }
	    fclose( pFile );
	}
    }
}

void CartRing::grabInfo (double& runTime, unsigned& numFrag, unsigned& nIter, double& Wcoh0, double& Wsum,
				double& Wmax, std::vector<double>& fragLength, double& meanFragLength,
				std::vector<unsigned>& fHisto, std::vector<std::vector<double> >& fragInvCDF){
    //Grabs information from a completed run and returns it to the post-processor
    runTime = clock()/CLOCKS_PER_SEC;
    numFrag = _numFrag;
    nIter = _Nt;
    Wcoh0 = _Wcoh[0];
    Wsum = _Wsum;
    Wmax = _Wmax;
    fragLength = _fragLength;
    meanFragLength = _fMean;
    fHisto = _fHisto;
    fragInvCDF = _fragInvCDF;
    
}

void CartRing::grabInfo (double& runTime, unsigned& numFrag, unsigned& nIter, double& Wcoh0, double& Wsum,
				double& Wmax, double& meanFragLength){
    //Grabs information from a completed run and returns it to the post-processor
    runTime = clock()/CLOCKS_PER_SEC;
    numFrag = _numFrag;
    nIter = _Nt;
    Wcoh0 = _Wcoh[0];
    Wsum = _Wsum;
    Wmax = _Wmax;
    meanFragLength = _fMean;
    
}

void CartRing::defectLimit (const double& defectRange) {
    _defectRange = defectRange;
}

/*------------------------------ P R I V A T E -------------------------------*/

void CartRing::buildDiscretization () {

    // Build _NodPos 
    _NodPos.resize( 2*_Nx ); 
    for ( unsigned i = 1; i <= _Nx; i++ ) { 
        unsigned k = ( 2*i ) % ( 2*_Nx ); 
        _NodPos[2*i-1].resize( 2 ); 
        _NodPos[k].resize( 2 ); 
        double theta = 2*PI*i/_Nx; 
        _NodPos[2*i-1][0] = _R0 * cos( theta ); 
        _NodPos[2*i-1][1] = _R0 * sin( theta ); 
        _NodPos[k][0] = _R0 * cos( theta ); 
        _NodPos[k][1] = _R0 * sin( theta ); 
    } 

    // Build connectivities
    _SprCon.resize( _Nx );
    _CohCon.resize( _Nx );
    _NodCon.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _Nx; i++ ) {
        // Build _SpringConnec and _NodeConnec accordingly
        _SprCon[i].first = 2*i;
        _NodCon[2*i].first = i;
        _SprCon[i].second = 2*i+1;
        _NodCon[2*i+1].first = i;
        // Build _CoheJointConnec and _NodeConnec accordingly
        unsigned k = ( 2*(i+1) ) % ( 2*_Nx );
        _CohCon[i].first = 2*i+1;
        _NodCon[2*i+1].second = i;
        _CohCon[i].second = k;
        _NodCon[k].second = i;
    }
    printConnec();

    // Compute the element size
    std::vector<double> firstElmVec = sprVec ( 0 );
    _Dx = sqrt( pow( firstElmVec[0], 2 ) + pow( firstElmVec[1], 2 ) );
    _m = 0.5 * _rho * _A * _Dx;

    // Compute critical time-step
    _Dt_c = _Dx / _c;

    // Resize the kinematics
    _Dis.resize( _NodPos.size() );
    _Vel.resize( _NodPos.size() );
    _Acc.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _Dis[i].resize( 3 );
        _Dis[i][0].resize( 2 );
        _Dis[i][1].resize( 2 );
        _Dis[i][2].resize( 2 );
        _Vel[i].resize( 3 );
        _Vel[i][0].resize( 2 );
        _Vel[i][1].resize( 2 );
        _Vel[i][2].resize( 2 );
        _Acc[i].resize( 2 );
        _Acc[i][0].resize( 2 );
        _Acc[i][1].resize( 2 );
    }

    // Resize forces
    _Fspr.resize( _NodPos.size() );
    _Fcoh.resize( _NodPos.size() );
    _Fext.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _Fspr[i].resize( 2 );
        _Fcoh[i].resize( 2 );
        _Fext[i].resize( 2 );
        _Fext[i][0].resize( 2 );
        _Fext[i][1].resize( 2 );
    }

    // Resize dual variables
    _Stress.resize( _Nx );

    // Resize & initialize _Wcoh & _Wspr & _Wsum & _numFrag
    _Wcoh.resize(2);
    _Wspr = 0;
    _Wsum = 0;
    _Wext = 0.0;
    _numFrag = 0;
    _DSum = 0;

    //Initialize constant strain rate flag
    _ConstSRFlag = 0;

    // Resize vectors for BC
    _NodForcBC.resize(2);
    _ValForcBC.resize(2);
    _ValVelBC.resize(2);
    _VelForcReq.resize( _NodPos.size() );
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        _VelForcReq[i].resize( 2 );
    }

    // Set _T and _Nt to zero
    _T = 0.0;
    _Nt = 0; 

}

void CartRing::NewmarkPred () {

    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        // Velocities
        _Vel[i][1][0] = _Vel[i][0][0] + 0.5 * _Dt * _Acc[i][0][0];
        _Vel[i][1][1] = _Vel[i][0][1] + 0.5 * _Dt * _Acc[i][0][1];

        // Apply Boundary Conditions
        /* NOT YET SURE ON HOW TO DO IT */
        // Displacement
        _Dis[i][1][0] = _Dt * _Vel[i][1][0];
        _Dis[i][1][1] = _Dt * _Vel[i][1][1];
    }
}

void CartRing::NewmarkReso () {

    // Build the spring force vector
    _Wspr = 0.0;

    for ( unsigned i = 0; i < _SprCon.size(); i++ ) {
        _Wspr += sprForc( i );
    }

    // Build the cohesive force vector
    _Wcoh[0] = 0.0;
    _Wcoh[1] = 0.0;
    for ( unsigned i = 0; i < _CohCon.size(); i++ ) {
        std::vector<double> wCoh = cohForc( i );
        _Wcoh[0] += wCoh[0];
        _Wcoh[1] += wCoh[1];
    }

    //Adjust for constant Velocity / strain rate -- calculate _VelForcReq
    if ( (_ConstSRFlag == 1) && ( _Nt % 1 == 0 ) ) {
        for ( unsigned i = 0; i < _NodPos.size(); i++) {
	    calcVelForc(i);
        }
    }


    // Build the external force vector & Solve the system

    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        // Compute the external energy
        _Wext += extForc( i );

        // Solve the problem
        _Acc[i][1][0] = ( _Fext[i][1][0] + _Fspr[i][0] + _Fcoh[i][0] ) / _m;
        _Acc[i][1][1] = ( _Fext[i][1][1] + _Fspr[i][1] + _Fcoh[i][1] ) / _m;
    }
}

void CartRing::NewmarkCorr () {

    _Wkin = 0.0;
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {

        // Velocities
        /* SHOULD ACCOUNT FOR BOUNDARY CONDITIONS */
        _Vel[i][2][0] = _Vel[i][1][0] + 0.5 * _Dt * _Acc[i][1][0];
        _Vel[i][2][1] = _Vel[i][1][1] + 0.5 * _Dt * _Acc[i][1][1];

        // Compute the kinematic energy
        _Wkin += 0.5 * _m * ( pow( _Vel[i][2][0], 2 ) + pow( _Vel[i][2][1], 2 ) );
 
        // Displacements
        _Dis[i][2][0] = _Dis[i][1][0];
        _Dis[i][2][1] = _Dis[i][1][1];
    }
}

double CartRing::sprForc ( const unsigned sprNum ) {

    // Compute the stress
    _Stress[sprNum] = stress( sprNum );

    // Compute the axial force in the truss in the corotational frame
    double axiForc = _A * _Stress[sprNum];

    // Compute the spring element vector
    std::vector<double> elmVec = sprVecPred ( sprNum );
    double elmLength = sqrt( pow( elmVec[0], 2 ) + pow( elmVec[1], 2 ) );

    // Compute the nodal internal force in the cartesian frame
    _Fspr[_SprCon[sprNum].first ][0] =        axiForc * elmVec[0] / elmLength;
    _Fspr[_SprCon[sprNum].first ][1] =        axiForc * elmVec[1] / elmLength;
    _Fspr[_SprCon[sprNum].second][0] = -1.0 * axiForc * elmVec[0] / elmLength;
    _Fspr[_SprCon[sprNum].second][1] = -1.0 * axiForc * elmVec[1] / elmLength;

    // Return elmentary spring energy
    return  0.5 * _A * elmLength * pow( _Stress[sprNum], 2 ) / _E;
}

std::vector<double> CartRing::cohForc ( const unsigned cohNum ) {

    // Find out the nodes connected to cohNum 
    unsigned nod_1 = _CohCon[cohNum].first;
    unsigned nod_2 = _CohCon[cohNum].second;

    bool cohMod = ( _ActivCoh.size() == _CohCon.size() )
                ? _ActivCoh[cohNum] : false;

    std::vector<double> wCoh(2);
    // Compute the cohesive force
    if ( cohMod == false ) {
        _Fcoh[nod_1][0] = -0.5 * ( _Fspr[nod_1][0] - _Fspr[nod_2][0] );
        _Fcoh[nod_1][1] = -0.5 * ( _Fspr[nod_1][1] - _Fspr[nod_2][1] );
        _Fcoh[nod_2][0] = -0.5 * ( _Fspr[nod_2][0] - _Fspr[nod_1][0] );
        _Fcoh[nod_2][1] = -0.5 * ( _Fspr[nod_2][1] - _Fspr[nod_1][1] );

        // Test the value of the cohesive stress
        if ( _SigC.size() == _Nx ) {
	    _sigCoh[cohNum] = 0;
            _sigCoh[cohNum] = cosThetaPred( nod_1 ) * _Fcoh[nod_1][1] / _A
            			- sinThetaPred( nod_1 ) * _Fcoh[nod_1][0] / _A;

	    bool defectRangeFlag = false;
	    if (_defectRange > 0) {
		int d_num = floor( _defectRange * (double)(_Nx) / _L) ;
                for (int i = -d_num; i <= d_num; i++) {
                    int j = ( i + (int)(cohNum) + _Nx) % _Nx;
		    if (_ActivCoh[j] == true) { 
			defectRangeFlag = true;
		    }
	        }
	    }

            if ( ( _sigCoh[cohNum] > _SigC[cohNum] ) && (defectRangeFlag == false) ) {
		//std::cout << "defectRangeFlagX:  " << defectRangeFlag <<std::endl;
                _ActivCoh[cohNum] = true;
                _Fcoh[nod_1][0] = -1.0 * _A * _SigC[cohNum]
                                * sinThetaPred( nod_1 );
                _Fcoh[nod_1][1] = _A * _SigC[cohNum] * cosThetaPred( nod_1 );
                _Fcoh[nod_2][0] = _A * _SigC[cohNum] * sinThetaPred( nod_2 );
                _Fcoh[nod_2][1] = -1.0 * _A * _SigC[cohNum]
                                * cosThetaPred( nod_2 );
            }
        }
    }
    else {
        // Compute crack opening and dammage
        std::vector<double> crack = cohVecPred( cohNum );
	//_delta[cohNum] = 0;
        _delta[cohNum] = sqrt( pow( crack[0], 2 ) + pow( crack[1], 2 ) );

	//Add sign to delta
	double xAvg = 0.5 * (cosThetaPred( _CohCon[cohNum].first ) + cosThetaPred( _CohCon[cohNum].second ));
	double yAvg = 0.5 * (sinThetaPred( _CohCon[cohNum].first ) + sinThetaPred( _CohCon[cohNum].second ));
	double d_theta = crack[1] * xAvg - crack[0] * yAvg;
	//double d_r = crack[0] * cosThetaPred( _CohCon[cohNum].first )
	//	+ crack[1] * sinThetaPred( _CohCon[cohNum].first );
	//if (d_theta < 0) {_delta[cohNum] = -_delta[cohNum];}
	_delta[cohNum] = d_theta;	//d-theta delta		

        double dammage = _delta[cohNum] / _DelC[cohNum];
        if ( dammage > 1.0 || _D[cohNum][0] >= 1 ) {
            _D[cohNum][1] = 1.0;
        }
        else {
            _D[cohNum][1] = ( dammage > _D[cohNum][0] ) ? dammage : _D[cohNum][0];
        }
	
        // Compute the cohesive traction
	_sigCoh[cohNum] = 0;
        cohStr( cohNum ); //assign _sigCoh

        // Compute the cohesive force
	double cosPhi = -sinTheta(_CohCon[cohNum].first);
	double sinPhi = cosTheta(_CohCon[cohNum].first);

        _Fcoh[nod_1][0] = _A * _sigCoh[cohNum] * cosPhi;
        _Fcoh[nod_1][1] = _A * _sigCoh[cohNum] * sinPhi;
        _Fcoh[nod_2][0] = -1.0 * _A * _sigCoh[cohNum] * cosPhi;
        _Fcoh[nod_2][1] = -1.0 * _A * _sigCoh[cohNum] * sinPhi;

        // Compute energy
        wCoh[0] = 0.5 * _A * _SigC[cohNum] * _D[cohNum][1] * _DelC[cohNum];
        wCoh[1] = 0.5 * _A * _sigCoh[cohNum] * _delta[cohNum];

	//Check for disagreement between element stress and coh-link stress
	//	e.g. - CTC, TCT
	double sigR = _Stress[cohNum];		
	double sigL = _Stress[ ((cohNum+1) % _Nx) ];
	if (_sigCoh[cohNum] != 0) {		
	if ((sigL*sigR > 0) && (sigL/fabs(sigL) != _sigCoh[cohNum]/fabs(_sigCoh[cohNum]))) {
        /*    FILE * pFile;
            pFile = fopen ( _logPath.c_str(), "a" );
            fprintf( pFile, "Cohesive Link Stress disagreement:  _T = %f  Link # = %u\n", _T, cohNum );
            fprintf( pFile, "    sigmaL = %e  sigmaR = %e  sigmaC = %e\n", sigL, sigR, _sigCoh[cohNum] );
            fclose( pFile );*/
	}}

    }
    return wCoh;
}

void CartRing::calcVelForc ( const unsigned i ) {
    double type = _ValVelBC[0]; 		//1 for radial, 2 for rotational
    double target = _ValVelBC[1];
    bool ok = true;
    for (unsigned j = 0; j < _fragLoc.size(); j++) {
	if (_fragLoc[j] == i) {
	    ok = false;					//Fragment stops fragment loading only
	}
    }
    if ( (_ActivCohEnergy[1] == 0) /*&& ok*/) {			//Any damage cancels all- fix
        if (type == 1) {
            //Radial
	    double past = _Vel[i][0][0] * cosTheta(i) + _Vel[i][0][1] * sinTheta(i);		//v_r
	    double current = _Vel[i][1][0] * cosThetaPred(i) + _Vel[i][1][1] * sinThetaPred(i);	//v_r
	    double diff = (target - past * 0.5 - current * 0.5) * 2.00;

	    _VelForcReq[i][0] = ((diff / ( 1 * _Dt) ) * cosThetaPred(i)) * _m;
	    _VelForcReq[i][1] = ((diff / ( 1 * _Dt) ) * sinThetaPred(i)) * _m;

        } else if (type == 2) {
            //Rotational
	    double past = -_Vel[i][0][0] * sinTheta(i) + _Vel[i][0][1] * cosTheta(i);
	    double current = -_Vel[i][1][0] * sinThetaPred(i) + _Vel[i][1][1] * cosThetaPred(i);
	    double diff = (target - current * 0.5 - past * 0.5) * 2.0;
	    _VelForcReq[i][0] = (diff / ( 1 * _Dt) ) * _m * -sinThetaPred(i);
	    _VelForcReq[i][1] = (diff / ( 1 * _Dt) ) * _m * cosThetaPred(i);

        } else {
	    std::cout << "Direction unknown!" << std::endl; 
        }
    } else {
	_VelForcReq[i][0] = 0;
	_VelForcReq[i][1] = 0;
    }
}

double CartRing::extForc ( const unsigned nodNum ) {
    _Fext[nodNum][1][0] = 0;
    _Fext[nodNum][1][1] = 0; 
    if ( _NodForcBC[0] == 1 ) {
        // Constant radial force
        _Fext[nodNum][1][0] = _ValForcBC[0] * cosThetaPred( nodNum );
        _Fext[nodNum][1][1] = _ValForcBC[0] * sinThetaPred( nodNum ); 
    }

    if ( _NodForcBC[0] == 2 ) {
        // Linear radial force (goal: constant velocity)
    }

    if ( _NodForcBC[1] == 1 ) {
        // Torque
        double dist = sqrt( pow( _NodPos[nodNum][0] + _Dis[nodNum][1][0], 2 )
                          + pow( _NodPos[nodNum][1] + _Dis[nodNum][1][1], 2 ) );
        _Fext[nodNum][1][0] = -1.0 * _ValForcBC[1] / dist
                            * sinThetaPred( nodNum );
        _Fext[nodNum][1][1] = _ValForcBC[1] / dist * cosThetaPred( nodNum ); //+=
    }

    if ( (_ConstSRFlag == 1) /*&& ( _Nt % 5 == 0 )*/ ) {
	//Constant velocity / strain rate
	_Fext[nodNum][1][0] += _VelForcReq[nodNum][0];
        _Fext[nodNum][1][1] += _VelForcReq[nodNum][1];
	_VelForcReq[nodNum][0] = 0;
	_VelForcReq[nodNum][1] = 0;
    }

    // Compute contribution to external energy of the node
    double wExt = _Vel[nodNum][1][0] * ( _Fext[nodNum][1][0] + _Fext[nodNum][0][0] )
                + _Vel[nodNum][1][1] * ( _Fext[nodNum][1][1] + _Fext[nodNum][0][1] );
    return 0.5 * _Dt * wExt;
}

double CartRing::stress ( const unsigned sprNum ) const {

    // Compute a prediction of the element position vector
    std::vector<double> elmVec = sprVecPred( sprNum );

    // Compute the truss element / the spring current length
    double curLength = sqrt( pow( elmVec[0], 2 ) + pow( elmVec[1], 2 ) );

    // Compute the Crisfield version of the element strain
    double strain = ( pow( curLength, 2 ) - pow( _Dx, 2 ) )
                  / ( _Dx * ( curLength + _Dx ) );

    return  _E * strain;
}

void CartRing::cohStr ( const unsigned cohNum ) {
    _sigCoh[cohNum] = 0;
    if ( (_delta[cohNum] > 0.0) ) {
        // Tensile behavior
        if ( _delta[cohNum] > _DelC[cohNum] || _D[cohNum][0] >= 1.0 ) {
            // Fully broken link
            _sigCoh[cohNum] = 0.0;
        }
        else if ( _delta[cohNum] > _D[cohNum][0] * _DelC[cohNum]) {
            // Dammaging link
            /* 
               Only linear case implemented.
               Here their should be a function call to more sophisticated
               cohesive laws.
            */
            _sigCoh[cohNum] = _SigC[cohNum] * ( 1.0 - _delta[cohNum] / _DelC[cohNum] );

	    //Exponential Cohesive law
	    /*_sigCoh[cohNum] = _SigC[cohNum] *_delta[cohNum] / (_DelC[cohNum]/(2*exp(1))) *
		exp( 1.0 - _delta[cohNum] / (_DelC[cohNum]/(2*exp(1)) ));*/

        } else {
            // Elastic unloading/reloading
            _sigCoh[cohNum] = ( 1.0 - _D[cohNum][0] ) / _D[cohNum][0] * _SigC[cohNum]
                   * ( _delta[cohNum] / _DelC[cohNum] ); //(Martin's) 
        }
    } else {
        // Compressive behavior ( Penalty )
        double pen = 1.0e+0;
	_sigCoh[cohNum] = _delta[cohNum] * _E / _Dx * pen;

	//Exponential Cohesive law
	/*_sigCoh[cohNum] = _SigC[cohNum] *_delta[cohNum] / (_DelC[cohNum]/(2*exp(1))) *
	    exp( 1.0 - _delta[cohNum] / (_DelC[cohNum]/(2*exp(1)) ));*/
    }

}

void CartRing::energBalance () {

    double Wint = _Wspr + _Wcoh[0] + _Wcoh[1];
    _Wmax = ( Wint > _Wkin ) ? Wint : _Wkin;
    _Wmax = ( _Wmax > _Wext ) ? _Wmax : _Wext;
    _Wsum = fabs(_Wkin + Wint - _Wext);
    if ( _Wsum > 0.01 * _Wmax) {
	std::cout << "t = " << _T << "  - Energy Balance Violation: " << _Wsum << " > " << _Wmax * 0.01 << std::endl;
	FILE * pFile;
    	pFile = fopen ( _logPath.c_str(), "a" );
    	fprintf( pFile, "##    t = %12.3e  - Energy Balance Violation: %12.3e > %12.3e\n", _T, _Wsum, _Wmax * 0.01 );
    	fclose( pFile );
    }
	
    if (_Wsum > 0.05 * _Wmax) {
	FILE * pFile;
    	pFile = fopen ( _logPath.c_str(), "a" );
    	fprintf( pFile, "####    t = %12.3e  - Energy Generation Limit Exceeded (5%% Max) \n", _T );
    	fclose( pFile );
	std::cout << "-------------------------------------------------------" << std::endl;
	std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
	std::cout << "t = " << _T << "  - Energy Generation Limit Exceeded (5% Max): " << _Wsum << " > " 
	    << _Wmax * 0.05 <<std::endl;
	std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
	std::cout << "-------------------------------------------------------" << std::endl;
        _T += 500; //cause natural destruction;
    }
}

void CartRing::checkStable () {

    unsigned compression = 0;
    for (unsigned i = 0; i < _sigCoh.size(); i++) {  //if any cohesive link is in compression
	if (_sigCoh[i] < 0 ) {
	    compression = 1;
	    _tFlag[1] = 1;
	}
    }

    unsigned temp = 0;
    for (unsigned i = 0; i < _Nx; i++ ){
	//enable if any is at 95% critical stress, or is within critical damage range
 	if ( ( (_delta[i] > 0 ) && ( _D[i][1] < (_sigCoh[i]) / (_E/_Dx) )) || _sigCoh[i] > 0.95 * _SigC[i]) {
  	//needs improvement
	    temp += 1;
	}
    }
    
    if (temp == 0) {	//activate if in critical region
	_tFlag[1] += 0;
    } else {
	_tFlag[1] += 1;
    }

}

void CartRing::fragCount () {

    //Count the number of broken cohesive links
    _fragLoc.resize(0);
    _numFrag = 0;
    _DSum = 0;
    for (unsigned i = 0; i < _Nx; i++ ){
	
	_DSum += (_D[i][1] >= 1) ? 1 : _D[i][1];

	if (_D[i][1] >= 1){
		_numFrag += 1;
		_fragLoc.push_back(i);
	}
    }

    //Find the length of each fragment
    unsigned length = _fragLoc.size();
    if (length == 1){
	_fragLength.resize(1);
	_fragLength[0] = _Nx * _Dx;
    }else{
	double nElems = 0;
	_fragLength.resize(length);
	for (unsigned k = 0; k < _fragLength.size(); k++){
	    if (k == 0){
		nElems = fabs( _Nx - fabs( _fragLoc[0] - _fragLoc[length-1]));	//check this formula
	    }else{
		nElems = fabs( _fragLoc[k - 1] - _fragLoc[k]);
	    }
	    _fragLength[k] = nElems * _Dx;
	}
    }

    //Compute Statistics of fragment length distribution
    _fMean = 0;
    _fMed = 0;
    _fMax = 0;
    _fMin = 0;
    _fStDev = 0;
    _fRange = 0;

    if (length > 0){
	//Median
	sort(_fragLength.begin(), _fragLength.end());
	if (length % 2 == 0) {
		_fMed = ( _fragLength[ (unsigned)(length * 0.5) ] + _fragLength[ (unsigned)(length * 0.5) -1] ) * 0.5;
	} else {
		_fMed = _fragLength[ (length - 1) / 2 ];
	}

	//Max, Min, Range
	_fMax = _fragLength.back();
	_fMin = _fragLength.front();
	_fRange = _fMax - _fMin;
	
	//Mean, Std. Deviation (Rayleigh Distribution)
	for (unsigned k = 0; k < _fragLength.size(); k++){
		_fStDev += pow( _fragLength[k], 2);
		_fMean += _fragLength[k];
	}
	_fStDev = sqrt( _fStDev / (2*length) ) ;
	_fMean = _fMean / _fragLength.size();		
    }
}

void CartRing::timeStepRefine (const double refine) {
	if (_Nt == 0) {		//Initialization
	    _deactive = 0;	//first-level multiplier
	    _deactive2 = 0;	//second-level multiplier
	}

	if (_tFlag[1] != 0){	
	    if (_tFlag[0] == 0) {	//If flag went from nothing to something
		std::cout << "Adaptive time-step initiated. t = " << _T << std::endl;
		_deactive = 0.0;
		_deactive2 = 0.0;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step initiated. t =  %e\n", _T );
    		fclose( pFile );
	    }    
	    if (_tFlag[1] == 2) {	//If flag went from nothing to second level
		_Dt = refine * refine * _Dt;	//Second-level refinement
		_deactive = 0.0;
		_deactive2 = 0.0;
		if (_tFlag[0] != 2) {
		    std::cout << "Adaptive time-step refined. t = " << _T << std::endl;
		    FILE * pFile;
    		    pFile = fopen ( _logPath.c_str(), "a" );
    		    fprintf( pFile, "##    Adaptive time-step refined. t =  %e\n", _T );
    		    fclose( pFile );
		}
	    }
	    if ((_tFlag[1] == 1) && (_deactive2 == 0.0) && (_tFlag[0] != 2)) { //If not doing second-level ref
	 	_Dt = refine * _Dt;	//First-level refinement
	    }
	}

	if (_tFlag[1] == 0){
	    if (_tFlag[0] == 1) {	//If flag went from first level to zero
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released %e\n", _T );
    		fclose( pFile );
		_deactive = 1.0;	//Signal demand to decrease first-level refinement
	    }
	    if (_tFlag[0] == 2) {	//If flag went from second level to zero
		std::cout << "Adaptive time-step released. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step released. t =  %e\n", _T );
    		fclose( pFile );
		_deactive = 1.0;	//Signal demand to decrease first-level refinement
		_deactive2 = 1.0;	//Signal demand to decrease second-level refinement
	    }
	}

	if (_tFlag[1] == 1){
	    if (_tFlag[0] == 2) {	//If flag went from second level to first
		std::cout << "Adaptive time-step loosened. t = " << _T << std::endl;
		_deactive2 = 1.0;	//Signal demand to decrease second-level refinement
		_deactive = 0.0;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Adaptive time-step loosened. t =  %e\n", _T );
    		fclose( pFile );
	    }
	}
	
	if (_deactive != 0.0 && _deactive2 == 0.0) {	//If doing first-level refinement reduction
	    //Gradually relax the step linearly back to original over 10000 periods
	    _deactive = _deactive - 0.0002;
	    _Dt = _Dt * (1.0 + (refine - 1.0) * _deactive);
	    if (_deactive <= 0.0) {
		std::cout << "Gradual relaxing 1 --> 0 completed. t = " << _T << std::endl;
    		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 1 --> 0 completed. t =  %e\n", _T );
    		fclose( pFile );
		_deactive = 0.0;
	    }
	}
	if (_deactive2 != 0.0) {			//If doing second-level refinement reduction
	    //Gradually relax the step linearly back to original over 10000 periods
	    _deactive2 = _deactive2 - 0.0002;
	    _Dt = _Dt * refine * (1.0 + (refine - 1.0) * _deactive2);
	    if (_deactive2 <= 0.0 && _Nt != 0) {
		std::cout << "Gradual relaxing 2 --> 1 completed. t = " << _T << std::endl;
		FILE * pFile;
    		pFile = fopen ( _logPath.c_str(), "a" );
    		fprintf( pFile, "##    Gradual relaxing 2 --> 1 completed. t =  %e\n", _T );
    		fclose( pFile );
		_deactive2 = 0.0;
	    }
	}


	/*Time Step Refinement Summary:
		CartRing::checkStable() evaluates the current position of all cohesive links
		in the cohesive law diagram. Levels of refinement are warranted for either or
		both of the two following cases: critical zone and compression. Critical zone 
		means that one or more cohesive links is on the vertical axis at or above 95%
		of critical stress and left of the elastic modulus line. The elastic modulus
		line is the elastic modulus scaled by element length. So for an element to be
		within this critical zone warrants one level of time step refinement. The 
		second is compression. When any element has a cohesive stress less than zero, 
		it is considered to be in compression, and warrants one level of time step
		refinement. So, it there are compressive elements and critical-zone elements,
		the level of refinement is two. Either alone is one. None is none.

		A zero-level of time step refinement means that _Dt is just 0.8 times the
		critical time-step, _Dt_c. One level of refinement will multiply _Dt times an
		additional factor, 'refine'. When refinement is no longer called for, the
		multiplier of refine, _deactive, will go linearly from one to zero over 5000
		periods, linearly bringing the effective multiplier from 'refine' to 1. The
		second level of time-step refinement multiplies _Dt by 'refine' squared.
		Similarly, when only a single level is then required, _deactive2 varies from
		one to zero, bringing the effective multiplier from refine^2 to refine over
		5000 steps. Going from a second level to zero immediately will run through the
		_deactive2 sequence and then the _deactive sequence over a total of 10000
		 periods. */
}

void CartRing::update () {

    // Nodal positions, Kinematics & External forces 
    for ( unsigned i = 0; i < _NodPos.size(); i++ ) {
        for ( unsigned j = 0; j < 2; j++ ) {
            // Nodal positions
            _NodPos[i][j] += _Dis[i][2][j];
            // Kinematics
            _Dis[i][0][j]  = _Dis[i][2][j];
            _Vel[i][0][j]  = _Vel[i][2][j];
            _Acc[i][0][j]  = _Acc[i][1][j];
            // External forces
            _Fext[i][0][j] = _Fext[i][1][j];
        }
    }

    // Internal variables
    for ( unsigned i = 0; i < _D.size(); i++ ) {
        _D[i][0] = _D[i][1];
    }
}

double CartRing::cosTheta ( const unsigned nodNum ) const {

    double norm = sqrt( pow( _NodPos[nodNum][0], 2 )
                      + pow( _NodPos[nodNum][1], 2 ) );
    return _NodPos[nodNum][0] / norm;
}

double CartRing::cosThetaPred ( const unsigned nodNum ) const {

    double X = _NodPos[nodNum][0] + _Dis[nodNum][1][0];
    double Y = _NodPos[nodNum][1] + _Dis[nodNum][1][1];
    double norm = sqrt( pow( X, 2 ) + pow( Y, 2 ) );
    return X / norm;
}

double CartRing::sinTheta ( const unsigned nodNum ) const {

    double norm = sqrt( pow( _NodPos[nodNum][0], 2 )
                      + pow( _NodPos[nodNum][1], 2 ) );
    return _NodPos[nodNum][1] / norm;
}

double CartRing::sinThetaPred ( const unsigned nodNum ) const {

    double X = _NodPos[nodNum][0] + _Dis[nodNum][1][0];
    double Y = _NodPos[nodNum][1] + _Dis[nodNum][1][1];
    double norm = sqrt( pow( X, 2 ) + pow( Y, 2 ) );
    return Y / norm;
}

std::vector<double> CartRing::sprVec ( const unsigned sprNum ) const {

    // Get the connectivity of the element sprNum
    unsigned nod_1 = _SprCon[sprNum].first;
    unsigned nod_2 = _SprCon[sprNum].second;

    std::vector<double> elmVec (2);
    elmVec[0] = _NodPos[nod_2][0] - _NodPos[nod_1][0];
    elmVec[1] = _NodPos[nod_2][1] - _NodPos[nod_1][1];

    return elmVec;
}

std::vector<double> CartRing::sprVecPred ( const unsigned sprNum ) const {

    // Get the connectivity of the element sprNum
    unsigned nod_1 = _SprCon[sprNum].first;
    unsigned nod_2 = _SprCon[sprNum].second;

    std::vector<double> elmVec (2);
    elmVec[0] = ( _NodPos[nod_2][0] + _Dis[nod_2][1][0] ) 
              - ( _NodPos[nod_1][0] + _Dis[nod_1][1][0] );
    elmVec[1] = ( _NodPos[nod_2][1] + _Dis[nod_2][1][1] ) 
              - ( _NodPos[nod_1][1] + _Dis[nod_1][1][1] );

    return elmVec;
}

std::vector<double> CartRing::cohVecPred ( const unsigned cohNum ) const {

    // Get the connectivitCoh.size() == _CohCon.size() )
    //            ? _ActivCoy of the element cohNum
    unsigned nod_1 = _CohCon[cohNum].first;
    unsigned nod_2 = _CohCon[cohNum].second;

    std::vector<double> elmVec (2);
    elmVec[0] = ( _NodPos[nod_2][0] + _Dis[nod_2][1][0] )
              - ( _NodPos[nod_1][0] + _Dis[nod_1][1][0] );
    elmVec[1] = ( _NodPos[nod_2][1] + _Dis[nod_2][1][1] )
              - ( _NodPos[nod_1][1] + _Dis[nod_1][1][1] );
    return elmVec;
}

/*******************************************************************************

                M E T H O D S    T O     P R I N T     S T U F F

*******************************************************************************/

/*------------------------------- P U B L I C --------------------------------*/

void CartRing::plotAtNodes ( const std::vector<unsigned>& NodalIds ) {

    // Gnuplot file for radial velocity 
    FILE * pFileVr;
    std::string velRFile = _path+"/gnuplot/plotRadialVelo.plt";		//../results
    pFileVr = fopen( velRFile.c_str(), "w" );
    fprintf( pFileVr, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileVr, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileVr, " -- MH[DCML] (2010)\n");
    fprintf( pFileVr, "# Radial velocities at prescribed nodes\n" );
    fprintf( pFileVr, "set xlabel \"time (s)\"\n" );
    fprintf( pFileVr, "set ylabel \"radial velocities (m/s)\"\n" );
    fprintf( pFileVr, "set terminal png\n\n" );
    fprintf( pFileVr, "set output './pngFiles/nodalRadialVelo.png'\n");
    fprintf( pFileVr, "plot " );
    fclose( pFileVr );

    // Gnuplot file for circumferential velocity 
    FILE * pFileVt;
    std::string velTFile = _path+"/gnuplot/plotCircumVelo.plt";		//../results
    pFileVt = fopen( velTFile.c_str(), "w" );
    fprintf( pFileVt, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileVt, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileVt, " -- MH[DCML] (2010)\n");
    fprintf( pFileVt, "# Circumferential velocities at prescribed nodes\n" );
    fprintf( pFileVt, "set xlabel \"time (s)\"\n" );
    fprintf( pFileVt, "set ylabel \"circumferential velocities (m/s)\"\n" );
    fprintf( pFileVt, "set terminal png\n\n" );
    fprintf( pFileVt, "set output './pngFiles/nodalCircumVelo.png'\n");
    fprintf( pFileVt, "plot " );
    fclose( pFileVt );

    _NodesToPlot.resize( NodalIds.size() );
    _NodeFiles.resize( NodalIds.size() );
    for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
        _NodesToPlot[i] = NodalIds[i];
        std::string nodalId = StrOps<unsigned>::convert( NodalIds[i] );
        _NodeFiles[i] = _path+"/datFiles/node_" + nodalId + ".dat";	//../results
        // Prepare Gnuplot data file
        FILE * pFile;
        pFile = fopen( _NodeFiles[i].c_str(), "w" );
        fprintf( pFile, "# GNUPLOT file generated by <cartRing.h>" );
        fprintf( pFile, " -- MH [DCML] (2010)\n" );
        fprintf( pFile, "# Nodal quantities for node: %s\n", nodalId.c_str() );
        fprintf( pFile, "#       time          vr          vt\n" );
        fclose( pFile );
        // Complete velocity file
        std::string nodFil = "./datFiles/node_" + nodalId + ".dat";		//.
        pFileVr = fopen( velRFile.c_str(), "a" );
        fprintf( pFileVr, "\"%s\" usi 1:2 ti \"vr_%s\" w l",
                 nodFil.c_str(), nodalId.c_str() );
        if ( i != _NodesToPlot.size()-1 ) {
            fprintf( pFileVr, ",\\\n     " );
        }
        fclose( pFileVr );
        pFileVt = fopen( velTFile.c_str(), "a" );
        fprintf( pFileVt, "     \"%s\" usi 1:3 ti \"vt_%s\" w l ",
                 nodFil.c_str(), nodalId.c_str() );
        if ( i != _NodesToPlot.size()-1 ) {
            fprintf( pFileVt, ",\\\n     " );
        }
        fclose( pFileVt );
    }
}

void CartRing::plotAtElms ( const std::vector<unsigned>& ElmIds ) {

    // Gnuplot file for stresses
    FILE * pFileS;
    std::string stressFile = _path+"/gnuplot/plotStre.plt";	//../results
    pFileS = fopen( stressFile.c_str(), "w" );
    fprintf( pFileS, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileS, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileS, " -- MH[DCML] (2010)\n");
    fprintf( pFileS, "# Stresses at prescribed elements\n" );
    fprintf( pFileS, "set xlabel \"time (s)\"\n" );
    fprintf( pFileS, "set ylabel \"stress (Pa)\"\n" );
    fprintf( pFileS, "set terminal png\n\n" );
    fprintf( pFileS, "set output './pngFiles/elmStress.png'\n");
    fprintf( pFileS, "plot " );
    fclose( pFileS );

    _ElmsToPlot.resize( ElmIds.size() );
    _ElmFiles.resize( ElmIds.size() );
    for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
        _ElmsToPlot[i] = ElmIds[i];
        std::string elmId = StrOps<unsigned>::convert( ElmIds[i] );
        _ElmFiles[i] = _path+"/datFiles/elem_" + elmId + ".dat";	//../results
        // Prepare Gnuplot data file
        FILE * pFile;
        pFile = fopen( _ElmFiles[i].c_str(), "w" );
        fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
        fprintf( pFile, " -- MH [DCML] (2010)\n" );
        fprintf( pFile, "# Elm quantities for node: %s\n", elmId.c_str() );
        fprintf( pFile, "#       time          st\n" );
        fclose( pFile );
        // Complete stress file
        std::string elmFil = "./datFiles/elem_" + elmId + ".dat";		//.
        pFileS = fopen( stressFile.c_str(), "a" );
        fprintf( pFileS, "\"%s\" usi 1:2 ti \"st_%s\" w l ",
                 elmFil.c_str(), elmId.c_str() );
        if ( i != _ElmsToPlot.size()-1 ) {
            fprintf( pFileS, ",\\\n     " );
        }
        fclose( pFileS );
    }
}

void CartRing::plotEnergies () {

    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal png\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.png'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgCoh.png'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'WcoD' w l ,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'WcoE' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.png'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.png'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:6 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.png'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:8 ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:7 ti '0.01 * Wmax' w l\n\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time          Ws         Wcd         Wce");
    fprintf( pFile, "          Wx          Wk   0.01*Wmax        Wsum\n" );
    fclose( pFile );
}

void CartRing::plotCohLaw (const std::vector<unsigned>& cohNums){
    _cLaw.resize( cohNums.size() );
    for (unsigned i = 0; i < cohNums.size(); i++){
	_cLaw[i] = cohNums[i];
    }
    // Gnuplot file for cohesive link information
    FILE * pFileW;
    std::string cohFile = _path+"/gnuplot/plotCohLaw.plt";		//../results
    pFileW = fopen( cohFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Cohesive Law\n" );
    fprintf( pFileW, "set xlabel \"crack opening (m)\"\n" );
    fprintf( pFileW, "set ylabel \"traction (Pa)\"\n" );
    fprintf( pFileW, "set terminal png\n\n" );

    for (unsigned i = 0; i < _cLaw.size(); i++) {
	fprintf( pFileW, "s1(x) = %12.3e * ( 1.0 - x/%12.3e);\n", _SigC[ _cLaw[i] ], _DelC[ _cLaw[i] ] );
        fprintf( pFileW, "s(x) = ( x < %12.3e ? s1(x) : 0.0 );\n\n",  _DelC[ _cLaw[i] ] );
        fprintf( pFileW, "e(x) = x * %12.3e / %12.3e;\n\n",  _E, _Dx );
        fprintf( pFileW, "set output \"./pngFiles/CohLaw%u.png\"\n", i + 1);
        fprintf( pFileW, "set yrange [:%12.3e]\n", _SigC[ _cLaw[i] ]);
        fprintf( pFileW, "plot s(x) ti 'analytical %u' w l lw 3 , \\\n", _cLaw[i] );
        fprintf( pFileW, "    './datFiles/cohLaw.dat' usi %u:%u ti 'computed %u' w lp ,\\\n", i*2+2, 2*i+3, _cLaw[i] );
	fprintf( pFileW, "    e(x) ti 'Elastic Modulus' w l lw 3 ;\n\n");
    }
    fclose( pFileW );

    // Prepare Gnuplot data file
    _CohLawFile = _path+"/datFiles/cohLaw.dat";		//../results
    FILE * pFile;
    pFile = fopen( _CohLawFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Cohesive Link Information for selected links:");
    for (unsigned i = 0; i < _cLaw.size(); i++) {
        fprintf( pFile, " %u", _cLaw[i]);
    }    
    fprintf( pFile, "\n");
    fprintf( pFile, "#       time");
    for (unsigned i = 0; i < _cLaw.size(); i++) {
        fprintf( pFile, "    delta%u    sigma%u", _cLaw[i], _cLaw[i] );
    } 
    fprintf( pFile, "\n");
    fclose( pFile );
}

void CartRing::plotFrags (){
    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal png \n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.png'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );


    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"stress (Pa)\"\n" );
    fprintf( pFileW, "set output './pngFiles/SigL_R_C.png'\n");
    fprintf( pFileW, " plot './datFiles/fraginfo.dat' usi 1:10 ti 'SigL'w l,\\\n");
    fprintf( pFileW, "             './datFiles/fraginfo.dat' usi 1:11 ti 'SigR' w l,\\\n");
    fprintf( pFileW, "             './datFiles/fraginfo.dat' usi 1:13 ti 'SigC' w l\n\n");


    fprintf( pFileW, "set logscale y\n" );		//Time-step graph
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"_Dt\"\n" );
    fprintf( pFileW, "set terminal png \n\n" );
    fprintf( pFileW, "set output './pngFiles/dt.png'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:10 ti 'Refinement' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:9 ti 'Time Step Flag' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range  (Locations)\n");
    fclose( pFile );
}

void CartRing::plotHisto () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal png \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.png'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal png \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.png'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void CartRing::plotSTheta () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
    pFileW = fopen( sThetaFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <cartRing.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
    fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
    fprintf( pFileW, "set xrange [0:360]\n");
    fprintf( pFileW, "set terminal png \n\n" );
    fprintf( pFileW, "set output './pngFiles/stressThetaCL.png'\n");
    fprintf( pFileW, "plot './datFiles/stresstheta.dat' usi 4:5 ti 'Link Stress' w l;\n\n" );
    fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
    fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
    fprintf( pFileW, "set xrange [0:360]\n");
    fprintf( pFileW, "set terminal png \n\n" );
    fprintf( pFileW, "set output './pngFiles/stressThetaSE.png'\n");
    fprintf( pFileW, "plot './datFiles/stresstheta.dat' usi 2:3 ti 'Spring Stress' w l;\n\n" );

    fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
    fprintf( pFileW, "set ylabel \"Damage\"\n" );
    fprintf( pFileW, "set xrange [0:360]\n");
    fprintf( pFileW, "set terminal png \n\n" );
    fprintf( pFileW, "set output './pngFiles/stressThetaCLD.png'\n");
    fprintf( pFileW, "plot './datFiles/stresstheta.dat' usi 4:6 ti 'Damage' w l;\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _SThetaFile = _path +"/datFiles/stresstheta.dat";		//../results/
    FILE * pFile;
    pFile = fopen( _SThetaFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
    fclose( pFile );
}

void CartRing::display ( const unsigned timStepNumElas,
                     const unsigned timStepNumFrac ) {

    _DisplayFlag = true;
    _DtPrintElas = timStepNumElas;
    _DtPrintFrac = timStepNumFrac;
}

/*------------------------------ P R I V A T E -------------------------------*/

void CartRing::printConnec () const {

    if ( _Nx < 10 ) {
        printf ( "|--------------------------------------|\n" );
        printf ( "|           Connectivities             |\n" );
        printf ( "|--------------------------------------|\n" );
        printf ( "|      Springs     |   Cohesive Zones  |\n" );
        printf ( "|   n1         n2  |   n1          n2  |\n" );
        printf ( "|------------------|-------------------|\n" );
        for ( unsigned j = 0; j < _Nx; j++ ) {
            printf ( "|   %2d         %2d  |   %2d          %2d  |\n",
                     _SprCon[j].first, _SprCon[j].second,
                     _CohCon[j].first, _CohCon[j].second );
        }
        printf ( "|------------------|-------------------|\n" );
    }
}

void CartRing::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += StrOps<unsigned>::convert(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile );
}

void CartRing::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

void CartRing::printMesh ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    unsigned nodSize = _NodPos.size();
    fprintf ( pFile, "POINTS %d float\n", nodSize );
    for ( unsigned i = 0; i < nodSize; i++ ) {
        double x = _NodPos[i][0];
        double y = _NodPos[i][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", x, y, 0.0 );
    }
    unsigned sprSize = _SprCon.size();
    fprintf ( pFile, "\nCELLS %d %d\n", sprSize, 3*sprSize );
    for ( unsigned i = 0; i < sprSize; i++ ) {
        fprintf ( pFile, " %12d %12d %12d\n", 2, _SprCon[i].first,
                  _SprCon[i].second );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", sprSize );
    for ( unsigned i = 0; i < sprSize; i++ ) {
        fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printPointData ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    int pointData = _NodPos.size();
    fprintf ( pFile, "POINT_DATA %d", pointData );
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < _Dis.size(); i++ ) {
        double dx = _Dis[i][0][0];
        double dy = _Dis[i][0][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < _Vel.size(); i++ ) {
        double vx = _Vel[i][0][0];
        double vy = _Vel[i][0][1];
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printCellData ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", _Nx );
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < _Stress.size(); i++ ) {
        fprintf( pFile, " %12.3e\n", _Stress[i] );
    }
    fprintf( pFile, "\n" );
    fclose( pFile );
}

void CartRing::printNodalInfo () const {

    if ( _NodesToPlot.size() > 0 ) {
        FILE * pFile;

        for ( unsigned i = 0; i < _NodesToPlot.size(); i++ ) {
            unsigned nodNum = _NodesToPlot[i];
            double v_r = cosTheta( nodNum ) * _Vel[nodNum][0][0]
                       + sinTheta( nodNum ) * _Vel[nodNum][0][1];
            double v_t = cosTheta( nodNum ) * _Vel[nodNum][0][1]
                       - sinTheta( nodNum ) * _Vel[nodNum][0][0];
            pFile = fopen( _NodeFiles[i].c_str(), "a" );
            fprintf( pFile, "%12.3e", _T );
            fprintf( pFile, "%12.3e", v_r );
            fprintf( pFile, "%12.3e", v_t );
            fprintf( pFile, "\n" );
            fflush( pFile );
            fclose( pFile );
        }
    }
}

void CartRing::printElmInfo () const {

    if ( _ElmsToPlot.size() > 0 ) {
        FILE * pFile;

        for ( unsigned i = 0; i < _ElmsToPlot.size(); i++ ) {
            unsigned elmNum = _ElmsToPlot[i];
            pFile = fopen( _ElmFiles[i].c_str(), "a" );
            fprintf( pFile, "%12.3e", _T );
            fprintf( pFile, "%12.3e", _Stress[elmNum] );
            fprintf( pFile, "\n" );
            fclose( pFile );
        }
    }
}

void CartRing::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
        fprintf( pFile, "%12.3e", _Wspr );
        fprintf( pFile, "%12.3e", _Wcoh[0] );
        fprintf( pFile, "%12.3e", _Wcoh[1] );
        fprintf( pFile, "%12.3e", _Wext );
        fprintf( pFile, "%12.3e", _Wkin );
	fprintf( pFile, "%12.3e", _Wmax * 0.01 );
	fprintf( pFile, "%12.3e", _Wsum );
	fprintf( pFile, "%12.3f", (double)(_tFlag[1]) + .001 );	//Time-step plot
	fprintf( pFile, "%12.3e", _Dt/_Dt_c );
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printCohLaw () const {

    if ( _CohLawFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _CohLawFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < _cLaw.size(); i++ ) {
            fprintf( pFile, "%12.3e", _delta[ _cLaw[i] ] ); 	//delta
            fprintf( pFile, "%12.3e", _sigCoh[ _cLaw[i] ] );	//sigma
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printFrags () const {
    unsigned cohNum =19;
    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", _T );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12.3f", _DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	double SigR = _Stress[cohNum];
	double SigL = _Stress[ ((cohNum+1) % _Nx) ];
	double SigC = _sigCoh[cohNum];
	fprintf( pFile, "%12.3e", SigL );			//SigL
	fprintf( pFile, "%12.3e", SigR );			//SigR
	fprintf( pFile, "%12.3e", SigR * SigL);			//SigL*SigR
	fprintf( pFile, "%12.3e", SigC );			//SigC
	if (SigR * SigL > 0 ) {
	    fprintf( pFile, "%12.3e", SigR * SigL * SigL / fabs(SigL));	//SigL*SigR*sign(SigL)
	}
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < _fragLoc.size(); i++){
		fprintf( pFile, "%12.3f", _fragLoc[i] );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printSTheta () const {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < _Nx; i++) {
	    double sprTheta = (double)(360*(i+0.5))/(double)(_Nx);
	    double cohTheta = (double)(360*(i+1))/(double)(_Nx);
	    fprintf( pFile, "%12.3e", _T );
	    fprintf( pFile, "%12.3f", sprTheta );
            fprintf( pFile, "%12.3e", _Stress[i] );
            fprintf( pFile, "%12.3f", cohTheta );
            fprintf( pFile, "%12.3e", _sigCoh[i] );
            fprintf( pFile, "%12.3e", _D[i][0] );
            fprintf( pFile, "%12.3f", (double)(i) );
            fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void CartRing::printClean () const {

    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; rm *.vtk; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    system( shellCmd.c_str() );

}
